<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Michelson-Morley-Experiment-3D â€“ FrQFT</title>
    <style>
      body { margin: 0; }
    </style>
  </head>
  <body>

    <!-- *** Imports *** -->

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <!-- old version <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script> -->
    <!-- versions see: https://unpkg.com/browse/es-module-shims@1.5.4/ -->
    <script async src="https://unpkg.com/es-module-shims@1.5.4/dist/es-module-shims.js"></script>

    <!-- versions see: https://unpkg.com/browse/three@0.140.2/ -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.140.2/build/three.module.js",
          "const": "./js/const.js",
          "utilities": "./js/utilities.js",
          "render": "./js/render.js"
        }
      }
    </script>
    <!-- as local module file, like I would prefer -->
    <!-- !!! SyntaxError: Importing binding name 'TOUCH' is not found. -->
    <!-- <script type="importmap">
      {
        "imports": {
          "three": "./js/three.js/r140-0.140.2/three.module.js"
        }
      }
    </script> -->

    <script type="module">

      import * as THREE from 'three' // is needed as module with this name in deeper three.js structures

      import {
        pi2,
        blackColor,
        eleWidth,
        eleHeight,
      } from 'const' // with 'es-module-shims.js' using the relative local path './js/const.js' gives an error: TypeError: Module name, './js/const.js' does not resolve to a valid URL.
      import { objectValuesToArray } from 'utilities' // with 'es-module-shims.js' using the relative local path './js/utilities.js' gives an error: TypeError: Module name, './js/utilities.js' does not resolve to a valid URL.
      import { Render } from 'render' // with 'es-module-shims.js' using the relative local path './js/render.js' gives an error: TypeError: Module name, './js/render.js' does not resolve to a valid URL.


      /*--------------------
      Clock
      Renderer
      Scene
      Camera
      Light
      Controls
      --------------------*/
      const render = new Render( eleWidth, eleHeight )


      /*--------------------
      Position of
      Camera
      Light
      --------------------*/
      // controls.update() must be called after any manual changes to the camera's transform
      render.camera.position.set( 3, 2, 7 )
      render.controls.update()
                                                 
      render.spotLight.position.set( 4, 6, 10 )
                                                 
      /*--------------------
      Consts Local
      --------------------*/

      // Light, additional
      const spotLightSecondParamsObj = {
        color: 0xffffff,
        intensity: 0.5,
        // distance: Float,
        // angle: Radians,
        // penumbra: Float,
        // decay: Float,
      }
      const spotLightSecondParams = objectValuesToArray(spotLightSecondParamsObj)

      // Sender
      const senderGeometryFactor = 0.25
      const senderColor = 0x2050ff
      const senderCorpusSize = 0.5
      const senderMeshLambertMaterial = { color: senderColor, side: THREE.DoubleSide }
      const senderMaterial = new THREE.MeshLambertMaterial( senderMeshLambertMaterial )
      const senderCorpusBoxGeometryParamsObj = {
        width: senderCorpusSize * senderGeometryFactor,
        height: senderCorpusSize * senderGeometryFactor,
        dept: senderCorpusSize * senderGeometryFactor,
        // widthSegments: Integer,
        // heightSegments: Integer,
        // depthSegments: Integer,
      }
      const senderCorpusBoxGeometryParams = objectValuesToArray(senderCorpusBoxGeometryParamsObj)
      const senderCorpusGeometry = new THREE.BoxGeometry( ...senderCorpusBoxGeometryParams )
      const senderPyramidCylinderGeometryParamsObj = {
        radiusTop: 0.25 * senderGeometryFactor,
        radiusBottom: 0.5 * senderGeometryFactor,
        height: 1 * senderGeometryFactor,
        radialSegments: 4,
        heightSegments: 1,
        openEnded: true,
        // thetaStart: Float,
        // thetaLength: Float,
      }
      const senderPyramidCylinderGeometryParams = objectValuesToArray(senderPyramidCylinderGeometryParamsObj)
      const senderPyramidGeometry = new THREE.CylinderGeometry( ...senderPyramidCylinderGeometryParams )

      // Plates
      const plateThickness = 0.025
      const plateWidth = 0.5
      const plateHeight = 0.25
      const plateBoxGeometryParams = objectValuesToArray({
        width: plateWidth,
        height: plateHeight,
        dept: plateThickness,
        // widthSegments: Integer,
        // heightSegments: Integer,
        // depthSegments: Integer,
      })

      // Mirrors
      const mirrorColor = 0xe0e0e0
      const mirrorGeometry = new THREE.BoxGeometry( ...plateBoxGeometryParams )
      const mirrorParamsMeshLambertMaterial = { color: mirrorColor, side: THREE.DoubleSide }
      const mirrorMaterial = new THREE.MeshLambertMaterial( mirrorParamsMeshLambertMaterial )
      const mirrorHalfMaterial = new THREE.MeshLambertMaterial({
        ...mirrorParamsMeshLambertMaterial,
        opacity: 0.5,
        transparent: true,
      })

      // Screen
      const screenColor = 0xffffff
      const screenGeometry = new THREE.BoxGeometry( ...plateBoxGeometryParams )
      const screenParamsMeshLambertMaterial = { color: screenColor, side: THREE.DoubleSide }
      const screenMaterial = new THREE.MeshLambertMaterial( screenParamsMeshLambertMaterial )

      // Scene Basics
      const centerHeightPosition = plateHeight / 2


      /*--------------------
      Light, additional
      --------------------*/
      const spotLightSecond = new THREE.SpotLight( ...spotLightSecondParams )
      spotLightSecond.castShadow = true
      render.scene.add( spotLightSecond )
      spotLightSecond.position.set( -4, -2, 0 )
      // const spotLightSecondHelper = new THREE.SpotLightHelper( spotLightSecond )
      // render.scene.add( spotLightSecondHelper )
      // const spotLightHelper = new THREE.SpotLightHelper( render.spotLight )
      // render.scene.add( spotLightHelper )

      /*--------------------
      Grid
      --------------------*/
      const size = 4
      const divisions = 4
      const colorCenterLine = 0x009000
      const gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine )
      render.scene.add( gridHelper )

      /*--------------------
      Sender
      --------------------*/
      const senderGroup = new THREE.Group()
      render.scene.add( senderGroup )
      // Corpus
      const senderCorpus = new THREE.Mesh( senderCorpusGeometry, senderMaterial )
      senderGroup.add( senderCorpus )
      // Pyramid
      const senderPyramid = new THREE.Mesh( senderPyramidGeometry, senderMaterial )
      senderPyramid.rotation.set( pi2 / 4, pi2 / 8, 0)
      senderPyramid.position.set( 0, 0, - (senderPyramidCylinderGeometryParamsObj.height / 2) )
      senderGroup.add( senderPyramid )
      // Sender Place
      senderGroup.position.set( 0, centerHeightPosition, 1 + senderCorpusBoxGeometryParamsObj.dept / 2 )

      /*--------------------
      Mian Mirror
      --------------------*/
      const mirrorMain = new THREE.Mesh( mirrorGeometry, mirrorMaterial )
      render.scene.add( mirrorMain )
      mirrorMain.position.set( 0, centerHeightPosition, -1 )

      /*--------------------
      Side Mirror
      --------------------*/
      const mirrorSide = new THREE.Mesh( mirrorGeometry, mirrorMaterial )
      render.scene.add( mirrorSide )
      mirrorSide.rotation.set( 0, pi2 / 4, 0)
      mirrorSide.position.set( -1, centerHeightPosition, 0 )

      /*--------------------
      Center Half Mirror
      --------------------*/
      const mirrorCenter = new THREE.Mesh( mirrorGeometry, mirrorHalfMaterial )
      render.scene.add( mirrorCenter )
      mirrorCenter.rotation.set( 0, pi2 / 8, 0)
      mirrorCenter.position.set( 0, centerHeightPosition, 0 )

      /*--------------------
      Screen For Interference
      --------------------*/
      const screenInterference = new THREE.Mesh( screenGeometry, screenMaterial )
      render.scene.add( screenInterference )
      screenInterference.rotation.set( 0, - (pi2 / 4), 0)
      screenInterference.position.set( 1, centerHeightPosition, 0 )


      /*--------------------
      Animation
      --------------------*/
      var time = 0
      var movingTime = 0

      render.renderer.setAnimationLoop(() => {
        time = -( render.clock.getElapsedTime() * pi2 * 0.05 ) % 4,5
        movingTime = -time - 2

        // dphGroup.position.set( 0, 0, movingTime * pi2 * 0.05 )
        
        // dphPathCylinder.geometry.dispose()
        // dphPathCylinder.geometry = new THREE.CylinderGeometry( torusRadius * 0.25, torusRadius * 0.25, time * pi2 * 0.05, 32, 25 )
        // // dphPathCylinder.position.set( (time * pi2 * 0.05) * 0.5, 0, 0 )

        // wqGroups.forEach((wqGroup, ndx) => {
        //   wqGroup.position.set(
        //     Math.cos(-movingTime + pi2 / wqCount * ndx) * radius,
        //     Math.sin(-movingTime + pi2 / wqCount * ndx) * radius,
        //     0
        //   )
        //   // wqGroup.rotation.set( 0, 0, movingTime + pi2 / wqCount * ndx )
        //   // wqGroup.rotation.set( pi2 * 0.125, 0, movingTime + pi2 / wqCount * ndx )
        //   // let euler = new THREE.Euler( pi2 * 0.125, 0, movingTime + pi2 / wqCount * ndx, 'ZXY' )  // rotation axis order must be changed
        //   let euler = new THREE.Euler( pi2 * 0.0, 0, -movingTime + pi2 / wqCount * ndx, 'ZXY' )  // rotation axis order must be changed
        //   wqGroup.rotation.copy( euler )
        // })

        render.renderer.render( render.scene, render.camera )
      })

    </script>
  </body>
</html>

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Michelson-Morley-Experiment-3D â€“ FrQFT</title>
    <style>
      body { margin: 0; }
    </style>
  </head>
  <body>

    <!-- *** Imports *** -->

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <!-- old version <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script> -->
    <!-- versions see: https://unpkg.com/browse/es-module-shims@1.5.4/ -->
    <script async src="https://unpkg.com/es-module-shims@1.5.4/dist/es-module-shims.js"></script>

    <!-- versions see: https://unpkg.com/browse/three@0.140.2/ -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.140.2/build/three.module.js",
          "const": "./js/const.js",
          "utilities": "./js/utilities.js",
          "render": "./js/render.js",
          "MME-consts": "./js/Michelson-Morley-Experiment-3D/MME-consts.js"
        }
      }
    </script>
    <!-- as local module file, like I would prefer -->
    <!-- !!! SyntaxError: Importing binding name 'TOUCH' is not found. -->
    <!-- <script type="importmap">
      {
        "imports": {
          "three": "./js/three.js/r140-0.140.2/three.module.js"
        }
      }
    </script> -->

    <script type="module">

      import * as THREE from 'three' // is needed as module with this name in deeper three.js structures

      import {
        pi2,
        eleWidth,
        eleHeight,
      } from 'const' // with 'es-module-shims.js' using the relative local path './js/const.js' gives an error: TypeError: Module name, './js/const.js' does not resolve to a valid URL.
      import { objectValuesToArray } from 'utilities' // with 'es-module-shims.js' using the relative local path './js/utilities.js' gives an error: TypeError: Module name, './js/utilities.js' does not resolve to a valid URL.
      import { Render } from 'render' // with 'es-module-shims.js' using the relative local path './js/render.js' gives an error: TypeError: Module name, './js/render.js' does not resolve to a valid URL.

      // !!! does not work in a way that it makes all more easy and have lesser lines !!!
      // import * from 'MME-consts' // with 'es-module-shims.js' using the relative local path './js/Michelson-Morley-Experiment-3D/MME-consts.js' gives an error: TypeError: Module name, './js/Michelson-Morley-Experiment-3D/MME-consts.js' does not resolve to a valid URL.


      /*--------------------
      Clock
      Renderer
      Scene
      Camera
      Light
      Controls
      --------------------*/
      const render = new Render( eleWidth, eleHeight )


      /*--------------------
      Position of
      Camera
      Light
      --------------------*/
      // controls.update() must be called after any manual changes to the camera's transform
      render.camera.position.set( 3, 2, 7 )
      render.controls.update()
                                                 
      // render.spotLight.position.set( 4, 6, 10 )
      render.spotLight.position.set( 4, 2, 0 )
                                                 
      /*--------------------
      Consts Local
      --------------------*/

      /*--------
      Light, additional */
      const spotLightSecondParamsObj = {
        color: 0xffffff,
        intensity: 0.5,
        // distance: Float,
        // angle: Radians,
        // penumbra: Float,
        // decay: Float,
      }
      const spotLightSecondParams = objectValuesToArray(spotLightSecondParamsObj)

      /*--------
      Dimension Bowls */
      const bowlGeometryFactor = 1 / 16
      const bowlRadius = 1 * bowlGeometryFactor
      const bowlColor = 0xe01010
      const bowlMeshPhysicalMaterialParams = {
        color: bowlColor,
        // opacity: 0.5,
        // transparent: true,
        emissive: 0x000000,
        // metalness: 0.7,
        metalness: 0.2,
        flatShading: false,
        // roughness: 0.7,
        roughness: 0.9,
        // envMap: textureCube,
        // reflectivity: 1,
        reflectivity: 0.5,
        side: THREE.DoubleSide,
      }
      const bowlMaterial = new THREE.MeshPhysicalMaterial( bowlMeshPhysicalMaterialParams )
      const bowlSphereGeometryParamsObj = {
        radius: bowlRadius,
        widthSegments: 20,
        heightSegments: 20,
        // phiStart: Float,
        // phiLength: Float,
        // thetaStart: Float,
        // thetaLength: Float,
      }
      const bowlSphereGeometryParams = objectValuesToArray(bowlSphereGeometryParamsObj)
      const bowlSphereGeometry = new THREE.SphereGeometry( ...bowlSphereGeometryParams )

      /*--------
      Plates */
      const plateThickness = 0.025
      const plateWidth = 0.5
      const plateHeight = 0.25
      const plateBoxGeometryParamsObj = {
        width: plateWidth,
        height: plateHeight,
        dept: plateThickness,
        // widthSegments: Integer,
        // heightSegments: Integer,
        // depthSegments: Integer,
      }
      const plateBoxGeometryParams = objectValuesToArray( plateBoxGeometryParamsObj )

      /*--------
      Mirrors */
      const mirrorBoxColor = 0xe0e0e0
      const mirrorBoxGeometry = new THREE.BoxGeometry( ...plateBoxGeometryParams )
      const mirrorBoxMeshLambertMaterialParams = { color: mirrorBoxColor, side: THREE.DoubleSide }
      const mirrorMaterial = new THREE.MeshLambertMaterial( mirrorBoxMeshLambertMaterialParams )
      const mirrorHalfGeometryParamsObj = {
        ...plateBoxGeometryParamsObj,
        dept: plateBoxGeometryParamsObj.dept / 2,
      }
      const mirrorHalfGeometryParams = objectValuesToArray( mirrorHalfGeometryParamsObj )
      const mirrorHalfGeometry = new THREE.BoxGeometry( ...mirrorHalfGeometryParams )
      // const mirrorHalfMaterial = new THREE.MeshLambertMaterial({
      //   ...mirrorBoxMeshLambertMaterialParams,
      //   opacity: 0.5,
      //   transparent: true,
      // })
      const mirrorHalfMeshPhysicalMaterialParams = {
        color: mirrorBoxColor,
        // opacity: 0.5,
        // transparent: true,
        emissive: 0x000000,
        metalness: 0.7,
        flatShading: false,
        roughness: 0.5,
        // envMap: textureCube,
        reflectivity: 1,
        side: THREE.DoubleSide,
      }
      const mirrorHalfMaterial = new THREE.MeshPhysicalMaterial({
        ...mirrorHalfMeshPhysicalMaterialParams,
        opacity: 0.5,
        transparent: true,
      })
      const mirrorPlaneGeometryParams = objectValuesToArray({
        width: plateWidth,
        height: plateHeight,
        // widthSegments: Integer,
        // heightSegments: Integer,
      })
      const mirrorPlaneGeometry = new THREE.PlaneGeometry( ...mirrorPlaneGeometryParams )
      // const mirrorPlaneMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000, side: THREE.DoubleSide })
      const mirrorPlaneMeshPhysicalMaterialParams = {
        ...mirrorHalfMeshPhysicalMaterialParams,
        // color: 0xffd700,
        color: 0xffff00,
        side: THREE.FrontSide,
      }
      const mirrorPlaneMaterial = new THREE.MeshPhysicalMaterial( mirrorPlaneMeshPhysicalMaterialParams )

      /*--------
      Screen */
      const screenColor = 0xffffff
      const screenGeometry = new THREE.BoxGeometry( ...plateBoxGeometryParams )
      const screenParamsMeshLambertMaterial = { color: screenColor, side: THREE.DoubleSide }
      const screenMaterial = new THREE.MeshLambertMaterial( screenParamsMeshLambertMaterial )

      /*--------
      Sender */
      const senderGeometryFactor = 0.25
      const senderColor = 0x2050ff
      const senderCorpusSize = 0.5
      // const senderMeshLambertMaterialParams = { color: senderColor, side: THREE.DoubleSide }
      // const senderMaterial = new THREE.MeshLambertMaterial( senderMeshLambertMaterialParams )
      const senderMeshPhysicalMaterialParams = {
        color: senderColor,
        // opacity: 0.5,
        // transparent: true,
        emissive: 0x000000,
        metalness: 0.7,
        flatShading: false,
        roughness: 0.7,
        // envMap: textureCube,
        reflectivity: 1,
        side: THREE.DoubleSide,
      }
      const senderMaterial = new THREE.MeshPhysicalMaterial( senderMeshPhysicalMaterialParams )
      const senderCorpusBoxGeometryParamsObj = {
        width: senderCorpusSize * senderGeometryFactor,
        height: senderCorpusSize * senderGeometryFactor,
        dept: senderCorpusSize * senderGeometryFactor,
        // widthSegments: Integer,
        // heightSegments: Integer,
        // depthSegments: Integer,
      }
      const senderCorpusBoxGeometryParams = objectValuesToArray(senderCorpusBoxGeometryParamsObj)
      const senderCorpusGeometry = new THREE.BoxGeometry( ...senderCorpusBoxGeometryParams )
      const senderPyramidCylinderGeometryParamsObj = {
        radiusTop: 0.25 * senderGeometryFactor,
        radiusBottom: 0.5 * senderGeometryFactor,
        height: 1 * senderGeometryFactor,
        radialSegments: 4,
        heightSegments: 30,
        openEnded: true,
        // thetaStart: Float,
        // thetaLength: Float,
      }
      const senderPyramidCylinderGeometryParams = objectValuesToArray(senderPyramidCylinderGeometryParamsObj)
      const senderPyramidGeometry = new THREE.CylinderGeometry( ...senderPyramidCylinderGeometryParams )

      /*--------
      Laser */
      const laserColor = 0x00ff00
      const laserOpacity = 0.5
      const laserDiscsInside = false
      const laserPartsCount = 41
      const laserGeometryFactor = 0.125 * 0.1
      const laserCylinderGeometryParamsObj = {
        radiusTop: 1 * laserGeometryFactor,
        radiusBottom: 1 * laserGeometryFactor,
        height: (8 * laserGeometryFactor) / laserPartsCount,
        radialSegments: 40,
        heightSegments: 1,
        // openEnded: true,
        // thetaStart: Float,
        // thetaLength: Float,
      }
      const laserCylinderGeometryParams = objectValuesToArray(laserCylinderGeometryParamsObj)
      const laserGeometry = new THREE.CylinderGeometry( ...laserCylinderGeometryParams )
      const laserMeshLambertMaterialParams = {
        color: laserColor,
        opacity: laserOpacity,
        transparent: true,
        side: THREE.DoubleSide
      }
      const laserClearMeshLambertMaterialParams = {
        ...laserMeshLambertMaterialParams,
        opacity: !laserDiscsInside ? 0.0 : laserOpacity,
        transparent: true
      }
      const laserClosedTopMaterialsParams = [
        laserMeshLambertMaterialParams,
        laserMeshLambertMaterialParams,
        laserClearMeshLambertMaterialParams,
      ]
      const laserOpenEndedMaterialsParams = [
        laserMeshLambertMaterialParams,
        laserClearMeshLambertMaterialParams,
        laserClearMeshLambertMaterialParams,
      ]
      const laserClosedBottomMaterialsParams = [
        laserMeshLambertMaterialParams,
        laserClearMeshLambertMaterialParams,
        laserMeshLambertMaterialParams,
      ]
      const laserAnimated = true
      const laserSplitsCount = 4
      const laserSlpitsSeparated = true
      const laserSlpitsSeparationDistance = laserCylinderGeometryParamsObj.radiusTop

      /*--------
      Scene Basics */
      const centerDistance = 1
      const centerHeightPosition = plateHeight / 2


      /*--------------------
      Functions Local
      --------------------*/

      const mirrorCreate = (params) => {
        // params: {
        //   withMirrorPlane: Boolean, required
        //   mirrorBoxMaterial: Object, required
        //   mirrorPlaneMaterial: Object, required
        // }
        let mirror = null
        const mirrorBox = new THREE.Mesh( mirrorBoxGeometry, params.mirrorBoxMaterial )
        if (params.withMirrorPlane) {
          mirror = new THREE.Group()
          mirror.add( mirrorBox )
          const mirrorPlate = new THREE.Mesh( mirrorPlaneGeometry, params.mirrorPlaneMaterial )
          mirrorPlate.rotation.set( 0, pi2 / 2, 0)
          mirrorPlate.position.set( 0, 0, - (plateThickness / 2 + 0.001) )
          mirror.add( mirrorPlate )
        } else {
          mirror = mirrorBox
        }
        return mirror
      }

      const laserSplitCreate = (splitsCount) => {
        /*--------
        Group */
        const laserWaveGroup = new THREE.Group()
        render.scene.add( laserWaveGroup )
        laserWaveGroup.rotation.set( pi2 / 4, 0, 0)
        /*--------
        Parts */
        const laserPartsOpacity = (partIndex, partsCount) => {
          // ???: use GauÃŸ'sche Normalverteilung?
          return Math.sin( Math.PI * (partIndex / (partsCount - 1)) )
        }
        const laserPushMaterialByOpacityAry = (laserMaterials, materialParams, indexPart) => {
          laserMaterials.push( new THREE.MeshLambertMaterial(
            { ...materialParams, opacity: materialParams.opacity * laserPartsOpacity( indexPart, laserPartsCount ) / laserSplitsCount }
          ))
        }
        const laserParts = []
        for (let index = 0; index < laserPartsCount; index++) {
          let laserMaterials = []
          switch (index === 0 ? 'first' : index < laserPartsCount - 1 ? 'middle' : 'last') {
            case 'first':
              laserClosedTopMaterialsParams.forEach( (materialParams) => laserPushMaterialByOpacityAry( laserMaterials, materialParams, index ))
              break
            case 'middle':
              laserOpenEndedMaterialsParams.forEach( (materialParams) => laserPushMaterialByOpacityAry( laserMaterials, materialParams, index ))
              break
            case 'last':
              laserClosedBottomMaterialsParams.forEach( (materialParams) => laserPushMaterialByOpacityAry( laserMaterials, materialParams, index ))
              break
          }
          const laserPart = new THREE.Mesh( laserGeometry, laserMaterials )
          laserParts.push( laserPart )
          laserWaveGroup.add( laserPart )
          laserPart.position.set( 0, (laserCylinderGeometryParamsObj.height / 2) - laserCylinderGeometryParamsObj.height * index, 0, )
        }
        return { laserWaveGroup, laserParts }
      }

      const laserSplitedAddDistance = (index) => 
        laserSlpitsSeparated ?
          // half of the total height
          -(
            (
              laserCylinderGeometryParamsObj.radiusTop * 2 * laserSplitsCount
              + laserSlpitsSeparationDistance *  (laserSplitsCount - 1)
            ) / 2
          )
          // add a radius to be in the senter of the bottom split
          + laserCylinderGeometryParamsObj.radiusTop
          // shift to the next split
          + (laserCylinderGeometryParamsObj.radiusTop * 2 + laserSlpitsSeparationDistance) * index
          : 0

      const laserPiecePositionSet = (laserPiece, index, move) => 
        laserPiece.position.set(
          0,
          centerHeightPosition + (laserSlpitsSeparated ? laserSplitedAddDistance( index ) : 0),
          laserAnimated ? move : centerDistance / 2
        )
       

      /*--------------------
      Light, additional
      --------------------*/
      const spotLightSecond = new THREE.SpotLight( ...spotLightSecondParams )
      spotLightSecond.castShadow = true
      render.scene.add( spotLightSecond )
      // spotLightSecond.position.set( -4, -2, 10 )
      spotLightSecond.position.set( -4, -1, 2 )
      // const spotLightSecondHelper = new THREE.SpotLightHelper( spotLightSecond )
      // render.scene.add( spotLightSecondHelper )
      // const spotLightHelper = new THREE.SpotLightHelper( render.spotLight )
      // render.scene.add( spotLightHelper )

      /*--------------------
      Grid
      --------------------*/
      const size = 4
      const divisions = 4
      const colorCenterLine = 0x009000
      const gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine )
      render.scene.add( gridHelper )

      /*--------------------
      Dimension Bowls
      --------------------*/
      /*--------
      Group */
      const bowlsGroup = new THREE.Group()
      render.scene.add( bowlsGroup )
      bowlsGroup.position.set( 0, bowlRadius, 0 )
      /*--------
      Bowls */
      const bowls = [
        new THREE.Mesh( bowlSphereGeometry, bowlMaterial ),
        new THREE.Mesh( bowlSphereGeometry, bowlMaterial ),
        new THREE.Mesh( bowlSphereGeometry, bowlMaterial ),
        new THREE.Mesh( bowlSphereGeometry, bowlMaterial ),
      ]
      bowls.forEach((bowl, index) => {
        bowlsGroup.add( bowl )
        switch (index) {
          case 0:            
            bowl.position.set( centerDistance, 0, centerDistance )
            break
          case 1:            
            bowl.position.set( centerDistance, 0, -centerDistance )
            break
          case 2:            
            bowl.position.set( -centerDistance, 0, centerDistance )
            break
          case 3:            
            bowl.position.set( -centerDistance, 0, -centerDistance )
            break
        }
      })

      /*--------------------
      Mian Mirror
      --------------------*/
      const mirrorMain = mirrorCreate({
        withMirrorPlane: true,
        mirrorBoxMaterial: mirrorMaterial,
        mirrorPlaneMaterial: mirrorPlaneMaterial,
      })
      render.scene.add( mirrorMain )
      mirrorMain.rotation.set( 0, pi2 / 2, 0)
      mirrorMain.position.set( 0, centerHeightPosition, -centerDistance )

      /*--------------------
      Side Mirror
      --------------------*/
      const mirrorSide = mirrorCreate({
        withMirrorPlane: true,
        mirrorBoxMaterial: mirrorMaterial,
        mirrorPlaneMaterial: mirrorPlaneMaterial,
      })
      render.scene.add( mirrorSide )
      mirrorSide.rotation.set( 0, pi2 / 4, 0)
      mirrorSide.position.set( centerDistance, centerHeightPosition, 0 )

      /*--------------------
      Half Mirror
      --------------------*/
      const mirrorCenter = new THREE.Mesh( mirrorHalfGeometry, mirrorHalfMaterial )
      render.scene.add( mirrorCenter )
      mirrorCenter.rotation.set( 0, pi2 / 8, 0)
      mirrorCenter.position.set( 0, centerHeightPosition, 0 )

      /*--------------------
      Screen For Interference
      --------------------*/
      const screenInterference = new THREE.Mesh( screenGeometry, screenMaterial )
      render.scene.add( screenInterference )
      screenInterference.rotation.set( 0, - (pi2 / 4), 0)
      screenInterference.position.set( -centerDistance, centerHeightPosition, 0 )

      /*--------------------
      Sender
      --------------------*/
      /*--------
      Group */
      const senderGroup = new THREE.Group()
      render.scene.add( senderGroup )
      senderGroup.position.set( 0, centerHeightPosition, centerDistance + senderCorpusBoxGeometryParamsObj.dept / 2 )
      /*--------
      Corpus */
      const senderCorpus = new THREE.Mesh( senderCorpusGeometry, senderMaterial )
      senderGroup.add( senderCorpus )
      /*--------
      Pyramid */
      const senderPyramid = new THREE.Mesh( senderPyramidGeometry, senderMaterial )
      senderPyramid.rotation.set( pi2 / 4, pi2 / 8, 0)
      senderPyramid.position.set( 0, 0, - (senderPyramidCylinderGeometryParamsObj.height / 2) )
      senderGroup.add( senderPyramid )

      /*--------------------
      Laser
      --------------------*/
      const laserSplits = []
      for (let index = 0; index < laserSplitsCount; index++) {
        const laserSplit = laserSplitCreate( laserSplitsCount )
        laserSplits.push( laserSplit )
        laserPiecePositionSet( laserSplit.laserWaveGroup, index, centerDistance )
      }


      /*--------------------
      Animation
      --------------------*/

      var time = 0

      render.renderer.setAnimationLoop(() => {
        time = ( render.clock.getElapsedTime() * 1 ) % 2

        if (laserAnimated) {
          laserSplits.forEach( (laserSplit, index) => laserPiecePositionSet( laserSplit.laserWaveGroup, index, centerDistance - time ))
        }

        render.renderer.render( render.scene, render.camera )
      })

    </script>
  </body>
</html>
